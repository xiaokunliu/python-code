#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
以下f赋值语句从概念上讲会执行三个步骤
1.创建一个对象来代表值3
2.创建一个变量a，如果它还没有创建的话
3.将变量与新的对象3相连接

以具体术语来讲：
1.变量是一个系统表的元素，拥有指向对象的连接空间
2.对象是分配的一块内存,有足够的空间去表示它们所代表的值
3.引用是自动形成的变量到对象的指针

对象有两个标准的头信息：
其一是类型标志符去标识这个对象的类型（python的类型是与对象关联的，因而没有在变量前声明其类型）
其二是引用的计数器，用来决定是不是可以回收这个对象
"""
import copy

import sys

a = 3

"""
每当一个变量被赋予了一个新的对象，之前的那个对象占用空间就会被回收,这种自动回收的空间技术称为垃圾收集
"""
b = 9
b = "spam"  # 9 这个对象所占用的空间将被回收,对象的空间自动放入自由内存空间池，等待后来的对象使用


"""
垃圾回收：
1. x每次被设置为不同类型的对象，再python中，类型属于对象而不是变量名，由于变量名只是引用对象而已
2. 注意对象的引用值在此过程中逐个丢弃，对象所占用的空间将被回收,对象的空间自动放入自由内存空间池，等待后来的对象使用
3. 每个对象中保持了计数器，计数器记录了当前指向该对象的引用数目,一旦计数器为0，就会自动回收
"""
x = 42
x = 'sksksk'
x = 2.3834
x = [12,3,45,8]

"""
共享引用:多个变量引用同一个对象
"""
t1 = 20
t2 = t1
t1 += 10    #给一个变量赋予一个新的值，并不是替换了原始的对象，而是让这个变量去引用完全不同的对象，实际效果就是对一个变量赋值，仅仅会影响那个会赋值的变量
print(t1)
print(t2)


"""
列表、集合、字典是属于动态可变
"""
L1 = [2,3,4,]
L2 = L1  ## L1 和 L2均指向同一块内存区域
L1[0] = 12  ## L1 和 L2 的第一个元素均变为12

# 若要使L2不变，则必须将L1 和 L2指向不同的内存区域，使用拷贝对象的形式
L2 = L1[:]  ## 拷贝列表

# 字典、集合的copy要使用X.copy()的方法

# 拷贝的通用模块copy
copy_l1 = copy.copy(L1)
deepcopy_l1 = copy.deepcopy(L1)


"""
共享引用和相等
"""

L = [23,4,4,4]
M = [23,4,4,4]

L == M  #True  == 测试两个引用的对象是否有相同的值
L is M  #False is 检查对象的同一性，即两个变量名精确地指向同一个对象，比较实现的引用指针


p = 42
k = 42
p == k  # True
p is k  # True,why?
"""
小的整数和字符串被缓存并复用，在python中可以查询一个对象引用的次数,可以使用sys.getrefcount(obj),返回对象的引用次数
"""

