#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""
函数作用：
1.最大化的代码重用和最小化的代码冗余
2.流程的分解
函数基本概念：
def是可执行的代码
def创建一个对象并将其赋值给某一个变量名称
lambda创建一个对象并将其结果返回
return将一个结果对象发送给调用者
yield向调用者发回一个结果对象,但是记住它离开的地方
global定义一个模块级的变量并被赋值
nonlocal声明了一个将要赋值的一个封闭的函数变量
函数是通过赋值(对象引用)传递的
参数、返回值以及变量并不是声明
py的多态
python将某一个对象在某种语法的合理性交由对象自身类型来判断,即一个操作的意义取决于被操作的对象的类型
python的作用域法则
内嵌的模块是全局作用域
全局作用域的作用范围仅限于单个文件
每次对函数的调用都创建了一个新的本地作用域
赋值的变量名除非声明为全局变量或非本地变量,否则君威本地变量
所有其他的变量名称都可以归纳为本地、全局或内置
变量名称解析：LEGB原则
本地 -- 闭包函数  --  全局变量   --  built-in内置
内置作用域
> 使用import _builtin_才能使用内置作用域
> global:1)全局变量是位于模块文件内部的顶层的变量名
         2)全局变量如果是在函数内被赋值的话，必须经过声明
         3)全局变量名称在函数的内部不声明也可以被引用
global语句
> 全局变量是位于模板文件内部的顶层变量名称
> 全局变量如果是在函数内被赋值的话，必须经过声明
> 全局变量名在函数的内部不经过声明也可以被引用
最小化全局变量
> 使用单一的模块文件去定义所有的全局变量
> 全局变量在并行线程中的不同函数之间成了共享内存
最小化文件间的修改
> 在文件间进行通信最好的办法就是通过调用函数,传递参数,然后得到其返回值;而不是在一个模块文件中去修改另一个模块文件中的全局变量
> 当一个模块文件a导入到模块文件b中，b就具有访问a模块的全局变量的访问权，相当于能够访问一个对象的属性信息
嵌套作用域
> 一个引用(X)首先在本地(函数内)作用域查找变量名X，之后会在代码的语法上嵌套了的函数中的本地函数,从内到外查找，之后查找当前的全局作用域(模块文件)，
最后再由作用域内(模块__builtin__),全局声明将会直接从全局(模块文件)作用域进行搜索
> 在默认情况下，一个赋值(X = Value)创建或改变了变量名称X的当前作用域，如果X在函数内声明为全局变量，它将会创建或改变变量名X为整个模块的作用域，
另一方面，如果X在函数内声明为nonlocal,赋值会修改最近的嵌套函数的本地作用域中的名称X
工厂函数(闭合函数)
> 一个能够记住嵌套作用域的变量值的函数,尽管那个作用域或许已经不存在
for example:
    def maker(N):
        def action(X)；
            return X**N
        return action
fn = maker(2)
fn(3) > 9
fn(4) > 16
使用默认参数来保留嵌套作用域的状态
> 传递一个默认参数值传递给(记住)一个内嵌作用域内的对象
嵌套作用域和lambda
> lambda 能够看到在所编写的函数中可用的变量
作用域与带有循环变量的默认参数相比较
> 如果lambda或者def在函数中定义，嵌套在一个循环之中，并且嵌套的函数引用了上层作用域的变量，该变量被循环所改变，所有在这个循环中
产生的函数将会有相同的值--在最后一次循环中完成时被引用变量的值
global 与 nonlocal
> global 使得作用域查找从嵌套的模块的作用域开始，并且允许对那里的名称赋值，如果名称不存在于该模块中，作用域查找继续到内置作用域，
但是对全局名称的赋值总是在模块的作用域中创建或者修改它们
> nonlocal 限制作用域查找只是嵌套的def,要求名称已经存在于那里，并且允许对它们赋值,作用域查找不会继续到全局或内置作用域
for example:
    def tester1(start):
        state = start
        def nested(label):
            print label,state
    def tester2(start):
        state = start
        def nested(label):
            nonlocal state
            state += 1
            print label,state
_fn = tester1(0)
_fn("ham")   ## print ham 0
 _fn("spam") ## print spam 0
 _fn2 = tester2(0)
_fn2("ham")   ## print ham 0
_fn2("spam") ## print spam 1
参数传递
> 参数的传递是通过自动将对象赋值给本地变量名来实现
> 在函数内部的参数名的赋值不会影响调用者
> 改变函数的可变参数的值也许会对调用者有影响
> 不可变参数"通过值"进行传递
> 可变对象是通过"指针"进行传递的
函数参数传递基础知识
> 位置：从左至右进行匹配
> 关键字参数：通过参数名进行匹配,使用name=value用法
> 默认参数：为没有传入值的参数定义参数值
> 可变参数：收集任意多基于位置或关键字的参数
> 可变参数解包：传递任意多基于位置或关键字的参数
> Keyword-only：参数必须按照名称传递
"""

